// SPDX-FileCopyrightText:  2020-2026 The DOSBox Staging Team
// SPDX-FileCopyrightText:  2002-2021 The DOSBox Team
// SPDX-License-Identifier: GPL-2.0-or-later

#include "shell/autoexec.h"

#include "utils/checks.h"
#include "config/config.h"
#include "dosbox.h"
#include "utils/fs_utils.h"
#include "hardware/input/keyboard.h"
#include "hardware/input/mouse.h"
#include "config/setup.h"
#include "shell/shell.h"
#include "utils/string_utils.h"
#include "misc/unicode.h"

#include <algorithm>
#include <iostream>
#include <sstream>

CHECK_NARROWING();

// Uncomment line below to print the generated AUTOEXEC.BAT in the log output
// #define DEBUG_AUTOEXEC

// ***************************************************************************
// Constants
// ***************************************************************************

static const std::string AutoexecFileName = "AUTOEXEC.BAT";
static const std::string CmdBoot          = "@Z:\\BOOT.COM ";
static const std::string CmdConfig        = "@Z:\\CONFIG.COM ";
static const std::string CmdMount         = "@Z:\\MOUNT.COM ";
static const std::string CmdMouse         = "@Z:\\MOUSE.COM ";
static const std::string CmdImgMount      = "@Z:\\IMGMOUNT.COM ";
static const std::string CmdEchoOff       = "@ECHO OFF";
static const std::string CmdSet           = "@SET ";
static const std::string CmdSetPath       = "@SET PATH=";
static const std::string CmdCall          = "CALL ";
static const std::string CmdDriveC        = "@C:";
static const std::string ToNul            = " >NUL";
static const std::string Quote            = "\"";

constexpr char char_lf = 0x0a; // line feed
constexpr char char_cr = 0x0d; // carriage return

// ***************************************************************************
// AUTOEXEC.BAT data - both source and binary
// ***************************************************************************

// Generated AUTOEXEC.BAT, in UTF-8 format
static std::optional<std::string> autoexec_bat_utf8 = {};
// Generated AUTOEXEC.BAT, in DOS encoding, in a binary format,
static std::vector<uint8_t> autoexec_bat_bin = {};
// Code page used to generate 'autoexec_bat_bin'
static std::optional<uint16_t> vfile_code_page = {};

// Data to be used to generate AUTOEXEC.BAT

// If true, put ECHO OFF before the content of [autoexec] section
static bool autoexec_has_echo_off = false;
// Environment variables to be set in AUTOEXEC.BAT
static std::map<std::string, std::string> autoexec_variables = {};

enum class Placement {
	// Autogenerated commands placed BEFORE content of [autoexec]
	InitialAutogeneratedCommands,
	// User commands executed just before secure mode gets enabled
	CommandsBeforeSecureMode,
	// Command to enable secure mode
	SecureModeCommand,
	// Content of [autoexec] section from the configuration file(s)
	AutoexecSection,
	// Final commands to boot guest OS or start given program or BAT file
	CommandsAfterAutoexecSection,
};

// Lines to be placed in the generated AUTOEXEC.BAT, by section (placement)
static std::map<Placement, std::list<std::string>> autoexec_lines;

// ***************************************************************************
// AUTOEXEC.BAT generation code
// ***************************************************************************

// Warning: only execute this once, when the initial AUTOEXEC.BAT is being
// created. Data used to generate the file might change at runtime, affecting
// the length of strings; if this happens when executing the AUTOEXEC.BAT,
// changed offsets might confuse our COMMAND.COM, leading to errors.
static void create_autoexec_bat_utf8()
{
	assert(!autoexec_bat_utf8);
	autoexec_bat_utf8 = std::string();

	// Helper lambdas

	auto push_new_line = [&] {
		// DOS line ending is CR+LF
		autoexec_bat_utf8->push_back(char_cr);
		autoexec_bat_utf8->push_back(char_lf);
	};

	auto push_string = [&](const std::string& line) {
		if (line.empty()) {
			push_new_line();
			return;
		}

		for (const auto& character : line) {
			autoexec_bat_utf8->push_back(character);
		}
		push_new_line();
	};

	auto push_header = [&](const std::string& comment) {
		if (!autoexec_bat_utf8->empty()) {
			push_new_line();
		}
		push_string(comment);
		push_new_line();
	};

	// Generate AUTOEXEC.BAT, in UTF-8 format

	// If currently printed lines are generated from configuration files and
	// command line options
	bool is_pushing_generated = false;

	// If currently printed lines are from '[autoexec]' section(s)
	bool is_pushing_autoexec_section = false;

	// We want unprocessed UTF8 form of messages here (thus 'MSG_GetEnglishRaw'
	// calls, not 'MSG_Get'), they will be converted to DOS code page later,
	// together with the '[autoexec]' section content
	static const std::string comment_start = ":: ";

	const auto header_generated = comment_start +
	                              MSG_GetEnglishRaw("AUTOEXEC_BAT_GENERATED");

	const auto header_autoexec_section =
	        comment_start + MSG_GetEnglishRaw("AUTOEXEC_BAT_CONFIG_SECTION");

	// Put 'ECHO OFF' and 'SET variable=value' if needed

	if (autoexec_has_echo_off || !autoexec_variables.empty()) {
		push_string(header_generated);
		is_pushing_generated = true;

		if (autoexec_has_echo_off) {
			push_new_line();
			push_string(CmdEchoOff);
		}

		if (!autoexec_variables.empty()) {
			push_new_line();
			for (const auto& [name, value] : autoexec_variables) {
				push_string(CmdSet + name + "=" + value);
			}
		}
	}

	if (is_pushing_generated) {
		push_new_line();
	}

	// Put remaining AUTOEXEC.BAT content

	for (const auto& [placement, list_lines] : autoexec_lines) {
		if (list_lines.empty()) {
			continue;
		}

		switch (placement) {
		case Placement::InitialAutogeneratedCommands:
		case Placement::CommandsBeforeSecureMode:
		case Placement::SecureModeCommand:
		case Placement::CommandsAfterAutoexecSection:
			if (!is_pushing_generated) {
				push_header(header_generated);
				is_pushing_generated        = true;
				is_pushing_autoexec_section = false;
			} else if (placement == Placement::CommandsBeforeSecureMode ||
			           placement == Placement::SecureModeCommand) {
				push_new_line();
			}
			break;
		case Placement::AutoexecSection:
			if (!is_pushing_autoexec_section) {
				push_header(header_autoexec_section);
				is_pushing_generated        = false;
				is_pushing_autoexec_section = true;
			}
			break;
		default: assert(false);
		}

		// Push the content of the current AUTOEXEC.BAT section
		for (const auto& autoexec_line : list_lines) {
			push_string(autoexec_line);
		}
	}

#ifdef DEBUG_AUTOEXEC
	LOG_INFO("AUTOEXEC: New file content\n\n%s", autoexec_bat_utf8->c_str());
#endif // DEBUG_AUTOEXEC
}

static void create_autoexec_bat_bin(const uint16_t code_page)
{
	assert(autoexec_bat_utf8);

	// Convert UTF-8 AUTOEXEC.BAT to DOS code page
	const auto autoexec_bat_dos = utf8_to_dos(*autoexec_bat_utf8,
	                                          DosStringConvertMode::WithControlCodes,
	                                          UnicodeFallback::Box,
	                                          code_page);

	// Convert the result to a binary format
	autoexec_bat_bin = std::vector<uint8_t>(autoexec_bat_dos.begin(),
	                                        autoexec_bat_dos.end());

	// Store current code page for caching purposes
	vfile_code_page = code_page;
}

// ***************************************************************************
// AUTOEXEC class declaration and implementation
// ***************************************************************************

class AutoExecModule final {
public:
	AutoExecModule(Section* configuration);

private:
	void ProcessConfigFile(const AutoExecSection& section,
	                       const std::string& source_name);

	void AddLine(const Placement placement, const std::string& line);

	// Mount drives from standard location in host filesystem
	void AutoMountDetectedDrive(const std::string& dir_letter);
	// Mount drive C from a directory
	void AutoMountDriveC(const std::string& directory,
	                     const Placement placement = Placement::InitialAutogeneratedCommands);
	// Mount drive D as CD-ROM from images
	void AutoMountDriveD(const std::string& cdrom_images,
	                     const Placement placement = Placement::InitialAutogeneratedCommands);

	// Mount specified directory as drive C, after [autoexec] is executed,
	// just before executing the final command
	void ReMountDirAsDriveC(const std::string& directory);

	void AddMessages();
};

struct AutoMountSettings {
	std::string override_drive = {};
	std::string type           = {};
	std::string label          = {};
	bool readonly              = false;
	std::string path           = {};
	bool verbose               = false;
};

AutoExecModule::AutoExecModule(Section* configuration)
{
	AddMessages();

	// Get the [dosbox] conf section
	const auto sec = static_cast<SectionProp*>(control->GetSection("dosbox"));
	assert(sec);

	// Start mouse driver
	if (MOUSEDOS_NeedsAutoexecEntry()) {
		AddLine(Placement::InitialAutogeneratedCommands, CmdMouse + ToNul);
	}

	// Auto-mount drives (except for DOSBox's Z:) prior to [autoexec]
	if (sec->GetBool("automount")) {
		for (char letter = 'a'; letter < 'z'; ++letter) {
			AutoMountDetectedDrive({letter});
		}
	}

	// Check -securemode switch to disable mount/imgmount/boot after
	// running autoexec.bat
	const auto cmdline               = control->cmdline; // short-lived copy
	const auto arguments             = &control->arguments;
	const bool has_option_securemode = arguments->securemode;

	// Are autoexec sections permitted?
	const bool has_option_no_autoexec = arguments->noautoexec;

	// Should autoexec sections be joined or overwritten?
	const std::string section_pref   = sec->GetString("autoexec_section");
	const bool should_join_autoexecs = (section_pref == "join");

	// Check to see for extra command line options to be added
	// (before the command specified on commandline)
	std::string argument = {};

	bool exit_call_exists = false;
	while (cmdline->FindString("-c", argument, true)) {
#if defined(WIN32)
		// Replace single with double quotes so that mount commands
		// can contain spaces
		for (auto& character : argument) {
			if (character == '\'') {
				character = '\"';
			}
		}
#endif // Linux users can simply use \" in their shell

		// If the user's added an exit call, simply store that
		// fact but don't insert it because otherwise it can
		// precede follow on [autoexec] calls.
		if (argument == "exit" || argument == "\"exit\"") {
			exit_call_exists = true;
			continue;
		}
		AddLine(Placement::CommandsBeforeSecureMode, argument);
	}

	// Check for the -exit switch, which indicates they want to quit
	const bool exit_arg_exists = arguments->exit;

	// Check if instant-launch is active
	const bool using_instant_launch_with_executable = cmdline->HasExecutableName();

	// Should we add an 'exit' call to the end of autoexec.bat?
	const bool should_add_exit = exit_call_exists || exit_arg_exists ||
	                             using_instant_launch_with_executable;

	bool has_boot_image     = false;
	bool has_dir_or_command = false;

	std::string drive_c_directory = {};
	std::string cdrom_images      = {};

	unsigned int index = 1;
	while (cmdline->FindCommand(index++, argument)) {
		if (argument.starts_with("-")) {
			LOG_WARNING("CONFIG: Illegal command line switch '%s'",
			            argument.c_str());
			continue;
		}

		// Check if argument is a file/directory
		std_fs::path path = argument;
		bool is_directory = std_fs::is_directory(path);
		if (!is_directory) {
			path         = std_fs::current_path() / path;
			is_directory = std_fs::is_directory(path);
		}

		if (is_directory) {
			drive_c_directory  = argument;
			has_dir_or_command = true;
			continue;
		}

		path = argument;

		// Retrieve file extension
		auto extension_ucase = path.extension().string();
		if (!extension_ucase.empty() && extension_ucase[0] == '.') {
			extension_ucase = extension_ucase.substr(1);
		}
		upcase(extension_ucase);

		// Check if argument is a batch file
		if (extension_ucase == "BAT") {
			ReMountDirAsDriveC(path.parent_path().string());
			// BATch files are called else exit will not work
			AddLine(Placement::CommandsAfterAutoexecSection,
			        CmdCall + path.filename().string());
			has_dir_or_command = true;
			break;
		}

		// Check if argument is a boot image file
		if (extension_ucase == "IMG" || extension_ucase == "IMA") {
			AddLine(Placement::CommandsAfterAutoexecSection,
			        CmdBoot + Quote + argument + Quote);
			has_boot_image     = true;
			has_dir_or_command = true;
			break;
		}

		// Check if argument is a CD image
		if (extension_ucase == "ISO" || extension_ucase == "CUE") {
			if (!cdrom_images.empty()) {
				cdrom_images += " ";
			}
			cdrom_images += Quote + argument + Quote;
			continue;
		}

		// Consider argument as executable
		ReMountDirAsDriveC(path.parent_path().string());
		AddLine(Placement::CommandsAfterAutoexecSection,
		        path.filename().string());
		has_dir_or_command = true;
		break;
	}

	// Mount drives
	if (!drive_c_directory.empty()) {
		AutoMountDriveC(drive_c_directory);
	}
	if (!cdrom_images.empty()) {
		AutoMountDriveD(cdrom_images);
	}

	// Fetch [autoexec] sections
	if (!has_option_no_autoexec) {
		if (should_join_autoexecs) {
			ProcessConfigFile(*static_cast<const AutoExecSection*>(
			                          configuration),
			                  "one or more joined sections");
		} else if (!has_dir_or_command) {
			ProcessConfigFile(control->GetOverwrittenAutoexecSection(),
			                  control->GetOverwrittenAutoexecConf());
		} else {
			LOG_MSG("AUTOEXEC: Using commands provided on the command line");
		}
	}

	// Enable secure boot if needed
	if (has_option_securemode) {
		if (has_boot_image) {
			// Secure mode does not allow booting - so skip it
			LOG_WARNING("AUTOEXEC: Secure mode skipped as it does not allow booting");
		} else {
			AddLine(Placement::SecureModeCommand,
			        CmdConfig + "-securemode");
			// Safety measure to prevent malicious user from
			// interrupting AUTOEXEC.BAT execution until secure mode
			// is enabled
			KEYBOARD_WaitForSecureMode();
		}
	}

	// Add exit command if needed
	if (should_add_exit) {
		AddLine(Placement::CommandsAfterAutoexecSection, "@EXIT");
	}
}

void AutoExecModule::ProcessConfigFile(const AutoExecSection& section,
                                       const std::string& source_name)
{
	if (section.data.empty()) {
		return;
	}

	LOG_MSG("AUTOEXEC: Using autoexec from %s", source_name.c_str());

	auto check_echo_off = [](const std::string& line) {
		if (line.empty()) {
			return false;
		}

		std::string tmp = (line[0] == '@') ? line.substr(1) : line;
		if (tmp.length() < 8) {
			return false;
		}

		lowcase(tmp);
		if (!tmp.starts_with("echo") || !tmp.ends_with("off")) {
			return false;
		}

		tmp = tmp.substr(4, tmp.length() - 7);
		for (const auto character : tmp) {
			if (!isspace(character)) {
				return false;
			}
		}

		return true;
	};

	std::istringstream input;
	input.str(section.data);

	std::string line = {};

	bool is_first_line = true;
	while (std::getline(input, line)) {
		trim(line);

		// If the first line is 'echo off' command, skip it and replace
		// with auto-generated one

		if (is_first_line) {
			is_first_line = false;
			if (check_echo_off(line)) {
				autoexec_has_echo_off = true;
				continue;
			}
		}

		AddLine(Placement::AutoexecSection, line);
	}
}

void AutoExecModule::AddLine(const Placement placement, const std::string& line)
{
	autoexec_lines[placement].push_back(line);
}

// Specify a 'Drive' config object with allowed key and value types
std::unique_ptr<Config> specify_drive_conf()
{
	auto conf = std::make_unique<Config>();

	// Define the [drive] section
	const AutoMountSettings defaults = {};

	const auto prop = conf->AddSection("drive");

	// Define the allowed keys and types
	constexpr auto OnStartup = Property::Changeable::OnlyAtStart;

	prop->AddString("type", OnStartup, defaults.type.c_str())
	        ->SetValues({"dir", "floppy", "cdrom", "overlay"});

	prop->AddString("label", OnStartup, defaults.label.c_str());
	prop->AddString("path", OnStartup, defaults.path.c_str());

	prop->AddString("override_drive", OnStartup, defaults.override_drive.c_str());

	prop->AddBool("verbose", OnStartup, defaults.verbose);
	prop->AddBool("readonly", OnStartup, defaults.readonly);

	return conf;
}

// Parse a 'Drive' config file and return object with allowed key and
// value types
std::optional<AutoMountSettings> parse_drive_conf(const std_fs::path& conf_path)
{
	AutoMountSettings settings = {};

	// If the conf path doesn't exist, at least return the default quiet arg
	if (!path_exists(conf_path)) {
		return settings;
	}

	// If we couldn't parse it, return the defaults
	const auto conf = specify_drive_conf();
	assert(conf);
	if (!conf->ParseConfigFile("auto-mounted drive", conf_path.string())) {
		return settings;
	}

	const auto section = static_cast<SectionProp*>(conf->GetSection("drive"));

	const auto override_drive = section->GetString("override_drive");
	if (override_drive.length() == 1 && override_drive[0] >= 'a' &&
	    override_drive[0] <= 'y') {
		settings.override_drive = override_drive;
	} else if (!override_drive.empty()) {
		LOG_ERR("AUTOMOUNT: %s: setting 'override_drive = %s' is invalid",
		        conf_path.string().c_str(),
		        override_drive.c_str());
		LOG_ERR("AUTOMOUNT: The override_drive setting can be left empty or a drive letter from 'a' to 'y'");
	}

	settings.readonly = section->GetBool("readonly");
	settings.label    = section->GetString("label");
	settings.type     = section->GetString("type");
	settings.path     = section->GetString("path");
	settings.verbose  = section->GetBool("verbose");

	return settings;
}

// Build a command to mount a drive from a directory, based on the
// provided settings
std::string build_auto_mount_dir_cmd(const std::string_view dir_letter,
                                     const std_fs::path& drive_path,
                                     const std::optional<AutoMountSettings>& settings)
{
	auto command = CmdMount;

	if (!settings.has_value() || settings->override_drive.empty()) {
		command += dir_letter;
	} else {
		command += settings->override_drive;
	}

	command += " " + Quote + simplify_path(drive_path).string() + Quote;

	if (settings.has_value()) {
		if (!settings->type.empty()) {
			command += " -t " + settings->type;
		}

		if (!settings->label.empty()) {
			command += " -label " + settings->label;
		}

		if (settings->readonly) {
			command += " -ro";
		}

		if (!settings->verbose) {
			command += ToNul;
		}
	}

	return command;
}

// Get all files in the given directory that have the specified extensions
std::vector<std_fs::path> get_files_by_ext(const std_fs::path& drive_path,
                                           const std::vector<std::string_view>& extensions)
{
	std::vector<std_fs::path> paths = {};

	for (const auto& entry : std_fs::directory_iterator(drive_path)) {
		if (entry.exists() && entry.is_regular_file()) {
			const auto& path = entry.path();
			std::string ext  = path.extension().string();
			lowcase(ext);
			if (std::ranges::find(extensions, ext) != extensions.end()) {
				paths.push_back(path);
			}
		}
	}

	std::ranges::sort(paths, [](const std_fs::path& a, const std_fs::path& b) {
		return natural_compare(a.filename().string(), b.filename().string());
	});

	return paths;
}

// Build a command to mount CD images in a folder, based on the
// provided settings
std::string build_auto_mount_cd_images_cmd(const std::string_view dir_letter,
                                           const std::vector<std_fs::path>& image_paths,
                                           const std::optional<AutoMountSettings>& settings)
{
	auto command = CmdImgMount;

	if (!settings.has_value() || settings->override_drive.empty()) {
		command += dir_letter;
	} else {
		command += settings->override_drive;
	}

	for (const auto& path : image_paths) {
		command += " " + Quote + simplify_path(path).string() + Quote;
	}

	command += " -t iso -fs iso";

	// When mounting CD images via imgmount, we ignore the type
	// (always cdrom), the readonly flag (implied) and the label settings
	// (derived from the CD images themselves)
	if (settings.has_value() && !settings->verbose) {
		command += ToNul;
	}

	return command;
}

// Takes in a drive letter (eg: 'c') and attempts to mount the 'drives/c',
// extends system path if needed
void AutoExecModule::AutoMountDetectedDrive(const std::string& dir_letter)
{
	// Does drives/[x] exist?
	const auto drive_path = get_resource_path("drives", dir_letter);
	if (!path_exists(drive_path)) {
		return;
	}

	// Try parsing the [x].conf file
	const auto conf_path = drive_path.string() + ".conf";
	const auto settings  = parse_drive_conf(conf_path);

	// See if there are mountable images in drive_path
	const std::vector<std::string_view> cd_image_extensions = {".cue", ".iso"};
	const auto cd_image_paths = get_files_by_ext(drive_path, cd_image_extensions);

	// Explicitly setting the drive type to anything but 'cdrom' will force
	// dosbox to mount the path as a directory, even if there are mountable
	// images in the path
	if (cd_image_paths.empty() ||
	    (!settings->type.empty() && settings->type != "cdrom")) {
		// Install mount as an autoexec command
		AddLine(Placement::InitialAutogeneratedCommands,
		        build_auto_mount_dir_cmd(dir_letter, drive_path, settings));
	} else {
		// Install imgmount as an autoexec command
		AddLine(Placement::InitialAutogeneratedCommands,
		        build_auto_mount_cd_images_cmd(dir_letter, cd_image_paths, settings));
	}

	// Install PATH as an autoexec command
	if (settings.has_value() && !settings->path.empty()) {
		AddLine(Placement::InitialAutogeneratedCommands,
		        CmdSetPath + settings->path);
	}
}

void AutoExecModule::AutoMountDriveC(const std::string& directory,
                                     const Placement placement)
{
	AddLine(placement, CmdMount + "-u C" + ToNul);
	if (directory.empty()) {
		AddLine(placement, CmdMount + "C ." + ToNul);
	} else {
		AddLine(placement,
		        CmdMount + "C " + Quote + directory + Quote + ToNul);
	}
	AddLine(placement, CmdDriveC);
}

void AutoExecModule::AutoMountDriveD(const std::string& cdrom_images,
                                     const Placement placement)
{
	AddLine(placement, CmdMount + "-u D" + ToNul);
	AddLine(placement, CmdImgMount + "D " + cdrom_images + " -t iso" + ToNul);
}

void AutoExecModule::ReMountDirAsDriveC(const std::string& directory)
{
	AutoMountDriveC(directory, Placement::CommandsAfterAutoexecSection);
}

void AutoExecModule::AddMessages()
{
	MSG_Add("AUTOEXEC_BAT_GENERATED",
	        "generated from configuration and command line");
	MSG_Add("AUTOEXEC_BAT_CONFIG_SECTION", "from [autoexec] section");
}

void AUTOEXEC_SetVariable(const std::string& name, const std::string& value)
{
#if C_DEBUGGER
	if (!std::all_of(name.cbegin(), name.cend(), is_printable_ascii)) {
		E_Exit("AUTOEXEC: Variable name is not a printable ASCII");
	}
	if (!std::all_of(value.cbegin(), value.cend(), is_printable_ascii)) {
		E_Exit("AUTOEXEC: Variable value is not a printable ASCII");
	}
#endif

	auto name_upcase = name;
	upcase(name_upcase);

	// If shell is already running, refresh variable content
	if (auto shell = DOS_GetFirstShell()) {
		shell->SetEnv(name_upcase, value);
	}

	// Update our internal list of variables to set in AUTOEXEC.BAT
	if (value.empty()) {
		autoexec_variables.erase(name_upcase);
	} else {
		autoexec_variables[name_upcase] = value;
	}
}

static std::unique_ptr<AutoExecModule> autoexec_module{};

void AUTOEXEC_RefreshFile()
{
	// No need to do anything during the shutdown
	if (DOSBOX_IsShutdownRequested()) {
		return;
	}

	// Don't do anything if we did not collect the config data yet
	if (!autoexec_module) {
		return;
	}

	// Create the UTF-8 version of the file, if necesary
	if (!autoexec_bat_utf8) {
		create_autoexec_bat_utf8();
	}

	// No need to do anything if the code page used by UTF-8 engine is still
	// the same as when Z:\AUTOEXEC.BAT was generated/refreshed
	const auto code_page = get_utf8_code_page();
	if (!vfile_code_page || code_page != *vfile_code_page) {
		create_autoexec_bat_bin(code_page);
	}

	// Register/refresh Z:\AUTOEXEC.BAT file
	if (!VFILE_Update(AutoexecFileName.c_str(), autoexec_bat_bin)) {
		VFILE_Register(AutoexecFileName.c_str(), autoexec_bat_bin);
	}
}

void AUTOEXEC_Init()
{
	auto section = get_autoexec_section("autoexec");
	assert(section);

	autoexec_module = std::make_unique<AutoExecModule>(section);
	AUTOEXEC_RefreshFile();
}
